/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _List_base {
            pub _M_impl: root::std::_List_base__List_impl,
        }
        pub type _List_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _List_base__Tp_alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type _List_base__Node_alloc_type = root::std::_List_base__Tp_alloc_traits;
        pub type _List_base__Node_alloc_traits = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_base__List_impl {
            pub _M_node: root::std::_List_node<usize>,
        }
        pub type _List_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct list {
            pub _base: root::std::_List_base,
        }
        pub type list__Base = root::std::_List_base;
        pub type list__Tp_alloc_type = root::std::list__Base;
        pub type list__Tp_alloc_traits = root::std::list__Base;
        pub type list__Node_alloc_type = root::std::list__Base;
        pub type list__Node_alloc_traits = root::std::list__Base;
        pub type list_value_type<_Tp> = _Tp;
        pub type list_pointer = root::std::list__Tp_alloc_traits;
        pub type list_const_pointer = root::std::list__Tp_alloc_traits;
        pub type list_reference = root::std::list__Tp_alloc_traits;
        pub type list_const_reference = root::std::list__Tp_alloc_traits;
        pub type list_iterator = root::std::_List_iterator;
        pub type list_const_iterator = root::std::_List_const_iterator;
        pub type list_const_reverse_iterator =
            root::std::reverse_iterator<root::std::list_const_iterator>;
        pub type list_reverse_iterator = root::std::reverse_iterator<root::std::list_iterator>;
        pub type list_size_type = usize;
        pub type list_difference_type = isize;
        pub type list_allocator_type<_Alloc> = _Alloc;
        pub type list__Node<_Tp> = root::std::_List_node<_Tp>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        pub type iterator_traits_iterator_category = [u8; 0usize];
        pub type iterator_traits_value_type = [u8; 0usize];
        pub type iterator_traits_difference_type = [u8; 0usize];
        pub type iterator_traits_pointer = [u8; 0usize];
        pub type iterator_traits_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *mut _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *mut _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _List_node_base {
                pub _M_next: *mut root::std::__detail::_List_node_base,
                pub _M_prev: *mut root::std::__detail::_List_node_base,
            }
            #[test]
            fn bindgen_test_layout__List_node_base() {
                assert_eq!(
                    ::std::mem::size_of::<_List_node_base>(),
                    16usize,
                    concat!("Size of: ", stringify!(_List_node_base))
                );
                assert_eq!(
                    ::std::mem::align_of::<_List_node_base>(),
                    8usize,
                    concat!("Alignment of ", stringify!(_List_node_base))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<_List_node_base>()))._M_next as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(_List_node_base),
                        "::",
                        stringify!(_M_next)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<_List_node_base>()))._M_prev as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(_List_node_base),
                        "::",
                        stringify!(_M_prev)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
                pub fn _List_node_base_swap(
                    __x: *mut root::std::__detail::_List_node_base,
                    __y: *mut root::std::__detail::_List_node_base,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
                pub fn _List_node_base__M_transfer(
                    this: *mut root::std::__detail::_List_node_base,
                    __first: *const root::std::__detail::_List_node_base,
                    __last: *const root::std::__detail::_List_node_base,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNSt8__detail15_List_node_base10_M_reverseEv"]
                pub fn _List_node_base__M_reverse(this: *mut root::std::__detail::_List_node_base);
            }
            extern "C" {
                #[link_name = "\u{1}_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
                pub fn _List_node_base__M_hook(
                    this: *mut root::std::__detail::_List_node_base,
                    __position: *const root::std::__detail::_List_node_base,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNSt8__detail15_List_node_base9_M_unhookEv"]
                pub fn _List_node_base__M_unhook(this: *mut root::std::__detail::_List_node_base);
            }
            impl _List_node_base {
                #[inline]
                pub unsafe fn swap(
                    __x: *mut root::std::__detail::_List_node_base,
                    __y: *mut root::std::__detail::_List_node_base,
                ) {
                    _List_node_base_swap(__x, __y)
                }
                #[inline]
                pub unsafe fn _M_transfer(
                    &mut self,
                    __first: *const root::std::__detail::_List_node_base,
                    __last: *const root::std::__detail::_List_node_base,
                ) {
                    _List_node_base__M_transfer(self, __first, __last)
                }
                #[inline]
                pub unsafe fn _M_reverse(&mut self) {
                    _List_node_base__M_reverse(self)
                }
                #[inline]
                pub unsafe fn _M_hook(
                    &mut self,
                    __position: *const root::std::__detail::_List_node_base,
                ) {
                    _List_node_base__M_hook(self, __position)
                }
                #[inline]
                pub unsafe fn _M_unhook(&mut self) {
                    _List_node_base__M_unhook(self)
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_node<_Tp> {
            pub _base: root::std::__detail::_List_node_base,
            pub _M_data: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_iterator {
            pub _M_node: *mut root::std::__detail::_List_node_base,
        }
        pub type _List_iterator__Self = root::std::_List_iterator;
        pub type _List_iterator__Node<_Tp> = root::std::_List_node<_Tp>;
        pub type _List_iterator_difference_type = isize;
        pub type _List_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type _List_iterator_value_type<_Tp> = _Tp;
        pub type _List_iterator_pointer<_Tp> = *mut _Tp;
        pub type _List_iterator_reference<_Tp> = *mut _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_const_iterator {
            pub _M_node: *const root::std::__detail::_List_node_base,
        }
        pub type _List_const_iterator__Self = root::std::_List_const_iterator;
        pub type _List_const_iterator__Node<_Tp> = root::std::_List_node<_Tp>;
        pub type _List_const_iterator_iterator = root::std::_List_iterator;
        pub type _List_const_iterator_difference_type = isize;
        pub type _List_const_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type _List_const_iterator_value_type<_Tp> = _Tp;
        pub type _List_const_iterator_pointer<_Tp> = *mut _Tp;
        pub type _List_const_iterator_reference<_Tp> = *mut _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct priority_queue<_Sequence, _Compare> {
            pub c: _Sequence,
            pub comp: _Compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sequence>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
        }
        pub type priority_queue_value_type = [u8; 0usize];
        pub type priority_queue_reference = [u8; 0usize];
        pub type priority_queue_const_reference = [u8; 0usize];
        pub type priority_queue_size_type = [u8; 0usize];
        pub type priority_queue_container_type<_Sequence> = _Sequence;
        pub type priority_queue_value_compare<_Compare> = _Compare;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *mut _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits_pointer = [u8; 0usize];
        pub type __alloc_traits_const_pointer = [u8; 0usize];
        pub type __alloc_traits_value_type = [u8; 0usize];
        pub type __alloc_traits_reference = [u8; 0usize];
        pub type __alloc_traits_const_reference = [u8; 0usize];
        pub type __alloc_traits_size_type = [u8; 0usize];
        pub type __alloc_traits_difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = [u8; 0usize];
    }
    pub mod ClipperLib {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const ClipType_ctIntersection: root::ClipperLib::ClipType = 0;
        pub const ClipType_ctUnion: root::ClipperLib::ClipType = 1;
        pub const ClipType_ctDifference: root::ClipperLib::ClipType = 2;
        pub const ClipType_ctXor: root::ClipperLib::ClipType = 3;
        pub type ClipType = ::std::os::raw::c_uint;
        pub const PolyType_ptSubject: root::ClipperLib::PolyType = 0;
        pub const PolyType_ptClip: root::ClipperLib::PolyType = 1;
        pub type PolyType = ::std::os::raw::c_uint;
        pub const PolyFillType_pftEvenOdd: root::ClipperLib::PolyFillType = 0;
        pub const PolyFillType_pftNonZero: root::ClipperLib::PolyFillType = 1;
        pub const PolyFillType_pftPositive: root::ClipperLib::PolyFillType = 2;
        pub const PolyFillType_pftNegative: root::ClipperLib::PolyFillType = 3;
        pub type PolyFillType = ::std::os::raw::c_uint;
        pub type cInt = ::std::os::raw::c_longlong;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IntPoint {
            pub X: root::ClipperLib::cInt,
            pub Y: root::ClipperLib::cInt,
        }
        #[test]
        fn bindgen_test_layout_IntPoint() {
            assert_eq!(
                ::std::mem::size_of::<IntPoint>(),
                16usize,
                concat!("Size of: ", stringify!(IntPoint))
            );
            assert_eq!(
                ::std::mem::align_of::<IntPoint>(),
                8usize,
                concat!("Alignment of ", stringify!(IntPoint))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<IntPoint>())).X as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IntPoint),
                    "::",
                    stringify!(X)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<IntPoint>())).Y as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IntPoint),
                    "::",
                    stringify!(Y)
                )
            );
        }
        pub type Path = root::std::vector;
        pub type Paths = root::std::vector;
        pub const JoinType_jtSquare: root::ClipperLib::JoinType = 0;
        pub const JoinType_jtRound: root::ClipperLib::JoinType = 1;
        pub const JoinType_jtMiter: root::ClipperLib::JoinType = 2;
        pub type JoinType = ::std::os::raw::c_uint;
        pub const EndType_etClosedPolygon: root::ClipperLib::EndType = 0;
        pub const EndType_etClosedLine: root::ClipperLib::EndType = 1;
        pub const EndType_etOpenButt: root::ClipperLib::EndType = 2;
        pub const EndType_etOpenSquare: root::ClipperLib::EndType = 3;
        pub const EndType_etOpenRound: root::ClipperLib::EndType = 4;
        pub type EndType = ::std::os::raw::c_uint;
        pub type PolyNodes = root::std::vector;
        #[repr(C)]
        pub struct PolyNode__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct PolyNode {
            pub vtable_: *const PolyNode__bindgen_vtable,
            pub Contour: root::ClipperLib::Path,
            pub Childs: root::ClipperLib::PolyNodes,
            pub Parent: *mut root::ClipperLib::PolyNode,
            pub Index: ::std::os::raw::c_uint,
            pub m_IsOpen: bool,
            pub m_jointype: root::ClipperLib::JoinType,
            pub m_endtype: root::ClipperLib::EndType,
        }
        #[test]
        fn bindgen_test_layout_PolyNode() {
            assert_eq!(
                ::std::mem::size_of::<PolyNode>(),
                80usize,
                concat!("Size of: ", stringify!(PolyNode))
            );
            assert_eq!(
                ::std::mem::align_of::<PolyNode>(),
                8usize,
                concat!("Alignment of ", stringify!(PolyNode))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).Contour as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(Contour)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).Childs as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(Childs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).Parent as *const _ as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(Parent)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).Index as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(Index)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).m_IsOpen as *const _ as usize },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(m_IsOpen)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).m_jointype as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(m_jointype)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyNode>())).m_endtype as *const _ as usize },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyNode),
                    "::",
                    stringify!(m_endtype)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10ClipperLib8PolyNode7GetNextEv"]
            pub fn PolyNode_GetNext(
                this: *const root::ClipperLib::PolyNode,
            ) -> *mut root::ClipperLib::PolyNode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10ClipperLib8PolyNode6IsHoleEv"]
            pub fn PolyNode_IsHole(this: *const root::ClipperLib::PolyNode) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10ClipperLib8PolyNode6IsOpenEv"]
            pub fn PolyNode_IsOpen(this: *const root::ClipperLib::PolyNode) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10ClipperLib8PolyNode10ChildCountEv"]
            pub fn PolyNode_ChildCount(
                this: *const root::ClipperLib::PolyNode,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib8PolyNodeC1Ev"]
            pub fn PolyNode_PolyNode(this: *mut root::ClipperLib::PolyNode);
        }
        impl PolyNode {
            #[inline]
            pub unsafe fn GetNext(&self) -> *mut root::ClipperLib::PolyNode {
                PolyNode_GetNext(self)
            }
            #[inline]
            pub unsafe fn IsHole(&self) -> bool {
                PolyNode_IsHole(self)
            }
            #[inline]
            pub unsafe fn IsOpen(&self) -> bool {
                PolyNode_IsOpen(self)
            }
            #[inline]
            pub unsafe fn ChildCount(&self) -> ::std::os::raw::c_int {
                PolyNode_ChildCount(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PolyNode_PolyNode(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PolyTree {
            pub _base: root::ClipperLib::PolyNode,
            pub AllNodes: root::ClipperLib::PolyNodes,
        }
        #[test]
        fn bindgen_test_layout_PolyTree() {
            assert_eq!(
                ::std::mem::size_of::<PolyTree>(),
                104usize,
                concat!("Size of: ", stringify!(PolyTree))
            );
            assert_eq!(
                ::std::mem::align_of::<PolyTree>(),
                8usize,
                concat!("Alignment of ", stringify!(PolyTree))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PolyTree>())).AllNodes as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PolyTree),
                    "::",
                    stringify!(AllNodes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10ClipperLib8PolyTree8GetFirstEv"]
            pub fn PolyTree_GetFirst(
                this: *const root::ClipperLib::PolyTree,
            ) -> *mut root::ClipperLib::PolyNode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib8PolyTree5ClearEv"]
            pub fn PolyTree_Clear(this: *mut root::ClipperLib::PolyTree);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10ClipperLib8PolyTree5TotalEv"]
            pub fn PolyTree_Total(this: *const root::ClipperLib::PolyTree)
                -> ::std::os::raw::c_int;
        }
        impl PolyTree {
            #[inline]
            pub unsafe fn GetFirst(&self) -> *mut root::ClipperLib::PolyNode {
                PolyTree_GetFirst(self)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                PolyTree_Clear(self)
            }
            #[inline]
            pub unsafe fn Total(&self) -> ::std::os::raw::c_int {
                PolyTree_Total(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IntRect {
            pub left: root::ClipperLib::cInt,
            pub top: root::ClipperLib::cInt,
            pub right: root::ClipperLib::cInt,
            pub bottom: root::ClipperLib::cInt,
        }
        #[test]
        fn bindgen_test_layout_IntRect() {
            assert_eq!(
                ::std::mem::size_of::<IntRect>(),
                32usize,
                concat!("Size of: ", stringify!(IntRect))
            );
            assert_eq!(
                ::std::mem::align_of::<IntRect>(),
                8usize,
                concat!("Alignment of ", stringify!(IntRect))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<IntRect>())).left as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IntRect),
                    "::",
                    stringify!(left)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<IntRect>())).top as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IntRect),
                    "::",
                    stringify!(top)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<IntRect>())).right as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IntRect),
                    "::",
                    stringify!(right)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<IntRect>())).bottom as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(IntRect),
                    "::",
                    stringify!(bottom)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TEdge {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IntersectNode {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LocalMinimum {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OutRec {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Join {
            _unused: [u8; 0],
        }
        pub type PolyOutList = root::std::vector;
        pub type EdgeList = root::std::vector;
        pub type JoinList = root::std::vector;
        pub type IntersectList = root::std::vector;
        #[repr(C)]
        pub struct ClipperBase__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ClipperBase {
            pub vtable_: *const ClipperBase__bindgen_vtable,
            pub m_CurrentLM: root::__gnu_cxx::__normal_iterator<root::pointer>,
            pub m_MinimaList: root::ClipperLib::ClipperBase_MinimaList,
            pub m_UseFullRange: bool,
            pub m_edges: root::ClipperLib::EdgeList,
            pub m_PreserveCollinear: bool,
            pub m_HasOpenPaths: bool,
            pub m_PolyOuts: root::ClipperLib::PolyOutList,
            pub m_ActiveEdges: *mut root::ClipperLib::TEdge,
            pub m_Scanbeam: root::ClipperLib::ClipperBase_ScanbeamList,
        }
        pub type ClipperBase_MinimaList = root::std::vector;
        pub type ClipperBase_ScanbeamList =
            root::std::priority_queue<root::std::vector, root::std::less>;
        #[test]
        fn bindgen_test_layout_ClipperBase() {
            assert_eq!(
                ::std::mem::size_of::<ClipperBase>(),
                144usize,
                concat!("Size of: ", stringify!(ClipperBase))
            );
            assert_eq!(
                ::std::mem::align_of::<ClipperBase>(),
                8usize,
                concat!("Alignment of ", stringify!(ClipperBase))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClipperBase>())).m_CurrentLM as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_CurrentLM)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClipperBase>())).m_MinimaList as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_MinimaList)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClipperBase>())).m_UseFullRange as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_UseFullRange)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClipperBase>())).m_edges as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_edges)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClipperBase>())).m_PreserveCollinear as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_PreserveCollinear)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClipperBase>())).m_HasOpenPaths as *const _ as usize
                },
                73usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_HasOpenPaths)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClipperBase>())).m_PolyOuts as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_PolyOuts)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClipperBase>())).m_ActiveEdges as *const _ as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_ActiveEdges)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClipperBase>())).m_Scanbeam as *const _ as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClipperBase),
                    "::",
                    stringify!(m_Scanbeam)
                )
            );
        }
        extern "C" {
            # [ link_name = "\u{1}_ZN10ClipperLib11ClipperBase8AddPathsERKSt6vectorIS1_INS_8IntPointESaIS2_EESaIS4_EENS_8PolyTypeEb" ] 
 pub fn ClipperBase_AddPaths ( this : * mut root :: ClipperLib :: ClipperBase , ppg : * const root :: ClipperLib :: Paths , PolyTyp : root :: ClipperLib :: PolyType , Closed : bool , ) -> bool ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase9GetBoundsEv"]
            pub fn ClipperBase_GetBounds(
                this: *mut root::ClipperLib::ClipperBase,
            ) -> root::ClipperLib::IntRect;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase22DisposeLocalMinimaListEv"]
            pub fn ClipperBase_DisposeLocalMinimaList(this: *mut root::ClipperLib::ClipperBase);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase14AddBoundsToLMLEPNS_5TEdgeEb"]
            pub fn ClipperBase_AddBoundsToLML(
                this: *mut root::ClipperLib::ClipperBase,
                e: *mut root::ClipperLib::TEdge,
                IsClosed: bool,
            ) -> *mut root::ClipperLib::TEdge;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase12ProcessBoundEPNS_5TEdgeEb"]
            pub fn ClipperBase_ProcessBound(
                this: *mut root::ClipperLib::ClipperBase,
                E: *mut root::ClipperLib::TEdge,
                IsClockwise: bool,
            ) -> *mut root::ClipperLib::TEdge;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase14InsertScanbeamEx"]
            pub fn ClipperBase_InsertScanbeam(
                this: *mut root::ClipperLib::ClipperBase,
                Y: root::ClipperLib::cInt,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase11PopScanbeamERx"]
            pub fn ClipperBase_PopScanbeam(
                this: *mut root::ClipperLib::ClipperBase,
                Y: *mut root::ClipperLib::cInt,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase18LocalMinimaPendingEv"]
            pub fn ClipperBase_LocalMinimaPending(this: *mut root::ClipperLib::ClipperBase)
                -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase14PopLocalMinimaExRPKNS_12LocalMinimumE"]
            pub fn ClipperBase_PopLocalMinima(
                this: *mut root::ClipperLib::ClipperBase,
                Y: root::ClipperLib::cInt,
                locMin: *mut *const root::ClipperLib::LocalMinimum,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase12CreateOutRecEv"]
            pub fn ClipperBase_CreateOutRec(
                this: *mut root::ClipperLib::ClipperBase,
            ) -> *mut root::ClipperLib::OutRec;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase17DisposeAllOutRecsEv"]
            pub fn ClipperBase_DisposeAllOutRecs(this: *mut root::ClipperLib::ClipperBase);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase13DisposeOutRecEm"]
            pub fn ClipperBase_DisposeOutRec(
                this: *mut root::ClipperLib::ClipperBase,
                index: root::size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase18SwapPositionsInAELEPNS_5TEdgeES2_"]
            pub fn ClipperBase_SwapPositionsInAEL(
                this: *mut root::ClipperLib::ClipperBase,
                edge1: *mut root::ClipperLib::TEdge,
                edge2: *mut root::ClipperLib::TEdge,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase13DeleteFromAELEPNS_5TEdgeE"]
            pub fn ClipperBase_DeleteFromAEL(
                this: *mut root::ClipperLib::ClipperBase,
                e: *mut root::ClipperLib::TEdge,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase17UpdateEdgeIntoAELERPNS_5TEdgeE"]
            pub fn ClipperBase_UpdateEdgeIntoAEL(
                this: *mut root::ClipperLib::ClipperBase,
                e: *mut *mut root::ClipperLib::TEdge,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBaseC1Ev"]
            pub fn ClipperBase_ClipperBase(this: *mut root::ClipperLib::ClipperBase);
        }
        impl ClipperBase {
            #[inline]
            pub unsafe fn AddPaths(
                &mut self,
                ppg: *const root::ClipperLib::Paths,
                PolyTyp: root::ClipperLib::PolyType,
                Closed: bool,
            ) -> bool {
                ClipperBase_AddPaths(self, ppg, PolyTyp, Closed)
            }
            #[inline]
            pub unsafe fn GetBounds(&mut self) -> root::ClipperLib::IntRect {
                ClipperBase_GetBounds(self)
            }
            #[inline]
            pub unsafe fn DisposeLocalMinimaList(&mut self) {
                ClipperBase_DisposeLocalMinimaList(self)
            }
            #[inline]
            pub unsafe fn AddBoundsToLML(
                &mut self,
                e: *mut root::ClipperLib::TEdge,
                IsClosed: bool,
            ) -> *mut root::ClipperLib::TEdge {
                ClipperBase_AddBoundsToLML(self, e, IsClosed)
            }
            #[inline]
            pub unsafe fn ProcessBound(
                &mut self,
                E: *mut root::ClipperLib::TEdge,
                IsClockwise: bool,
            ) -> *mut root::ClipperLib::TEdge {
                ClipperBase_ProcessBound(self, E, IsClockwise)
            }
            #[inline]
            pub unsafe fn InsertScanbeam(&mut self, Y: root::ClipperLib::cInt) {
                ClipperBase_InsertScanbeam(self, Y)
            }
            #[inline]
            pub unsafe fn PopScanbeam(&mut self, Y: *mut root::ClipperLib::cInt) -> bool {
                ClipperBase_PopScanbeam(self, Y)
            }
            #[inline]
            pub unsafe fn LocalMinimaPending(&mut self) -> bool {
                ClipperBase_LocalMinimaPending(self)
            }
            #[inline]
            pub unsafe fn PopLocalMinima(
                &mut self,
                Y: root::ClipperLib::cInt,
                locMin: *mut *const root::ClipperLib::LocalMinimum,
            ) -> bool {
                ClipperBase_PopLocalMinima(self, Y, locMin)
            }
            #[inline]
            pub unsafe fn CreateOutRec(&mut self) -> *mut root::ClipperLib::OutRec {
                ClipperBase_CreateOutRec(self)
            }
            #[inline]
            pub unsafe fn DisposeAllOutRecs(&mut self) {
                ClipperBase_DisposeAllOutRecs(self)
            }
            #[inline]
            pub unsafe fn DisposeOutRec(&mut self, index: root::size_type) {
                ClipperBase_DisposeOutRec(self, index)
            }
            #[inline]
            pub unsafe fn SwapPositionsInAEL(
                &mut self,
                edge1: *mut root::ClipperLib::TEdge,
                edge2: *mut root::ClipperLib::TEdge,
            ) {
                ClipperBase_SwapPositionsInAEL(self, edge1, edge2)
            }
            #[inline]
            pub unsafe fn DeleteFromAEL(&mut self, e: *mut root::ClipperLib::TEdge) {
                ClipperBase_DeleteFromAEL(self, e)
            }
            #[inline]
            pub unsafe fn UpdateEdgeIntoAEL(&mut self, e: *mut *mut root::ClipperLib::TEdge) {
                ClipperBase_UpdateEdgeIntoAEL(self, e)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                ClipperBase_ClipperBase(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            # [ link_name = "\u{1}_ZN10ClipperLib11ClipperBase7AddPathERKSt6vectorINS_8IntPointESaIS2_EENS_8PolyTypeEb" ] 
 pub fn ClipperBase_AddPath ( this : * mut :: std :: os :: raw :: c_void , pg : * const root :: ClipperLib :: Path , PolyTyp : root :: ClipperLib :: PolyType , Closed : bool , ) -> bool ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase5ClearEv"]
            pub fn ClipperBase_Clear(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib11ClipperBase5ResetEv"]
            pub fn ClipperBase_Reset(this: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Clipper {
            pub __bindgen_padding_0: u64,
            pub m_Joins: root::ClipperLib::JoinList,
            pub m_GhostJoins: root::ClipperLib::JoinList,
            pub m_IntersectList: root::ClipperLib::IntersectList,
            pub m_ClipType: root::ClipperLib::ClipType,
            pub m_Maxima: root::ClipperLib::Clipper_MaximaList,
            pub m_SortedEdges: *mut root::ClipperLib::TEdge,
            pub m_ExecuteLocked: bool,
            pub m_ClipFillType: root::ClipperLib::PolyFillType,
            pub m_SubjFillType: root::ClipperLib::PolyFillType,
            pub m_ReverseOutput: bool,
            pub m_UsingPolyTree: bool,
            pub m_StrictSimple: bool,
            pub __bindgen_padding_1: [u64; 18usize],
        }
        pub type Clipper_MaximaList = root::std::list;
        #[test]
        fn bindgen_test_layout_Clipper() {
            assert_eq!(
                ::std::mem::size_of::<Clipper>(),
                280usize,
                concat!("Size of: ", stringify!(Clipper))
            );
            assert_eq!(
                ::std::mem::align_of::<Clipper>(),
                8usize,
                concat!("Alignment of ", stringify!(Clipper))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_Joins as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_Joins)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_GhostJoins as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_GhostJoins)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_IntersectList as *const _ as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_IntersectList)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_ClipType as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_ClipType)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_Maxima as *const _ as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_Maxima)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_SortedEdges as *const _ as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_SortedEdges)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_ExecuteLocked as *const _ as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_ExecuteLocked)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_ClipFillType as *const _ as usize },
                124usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_ClipFillType)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_SubjFillType as *const _ as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_SubjFillType)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_ReverseOutput as *const _ as usize },
                132usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_ReverseOutput)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_UsingPolyTree as *const _ as usize },
                133usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_UsingPolyTree)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Clipper>())).m_StrictSimple as *const _ as usize },
                134usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Clipper),
                    "::",
                    stringify!(m_StrictSimple)
                )
            );
        }
        extern "C" {
            # [ link_name = "\u{1}_ZN10ClipperLib7Clipper7ExecuteENS_8ClipTypeERSt6vectorIS2_INS_8IntPointESaIS3_EESaIS5_EENS_12PolyFillTypeE" ] 
 pub fn Clipper_Execute ( this : * mut root :: ClipperLib :: Clipper , clipType : root :: ClipperLib :: ClipType , solution : * mut root :: ClipperLib :: Paths , fillType : root :: ClipperLib :: PolyFillType , ) -> bool ;
        }
        extern "C" {
            # [ link_name = "\u{1}_ZN10ClipperLib7Clipper7ExecuteENS_8ClipTypeERSt6vectorIS2_INS_8IntPointESaIS3_EESaIS5_EENS_12PolyFillTypeES9_" ] 
 pub fn Clipper_Execute1 ( this : * mut root :: ClipperLib :: Clipper , clipType : root :: ClipperLib :: ClipType , solution : * mut root :: ClipperLib :: Paths , subjFillType : root :: ClipperLib :: PolyFillType , clipFillType : root :: ClipperLib :: PolyFillType , ) -> bool ;
        }
        extern "C" {
            # [ link_name = "\u{1}_ZN10ClipperLib7Clipper7ExecuteENS_8ClipTypeERNS_8PolyTreeENS_12PolyFillTypeE" ] 
 pub fn Clipper_Execute2 ( this : * mut root :: ClipperLib :: Clipper , clipType : root :: ClipperLib :: ClipType , polytree : * mut root :: ClipperLib :: PolyTree , fillType : root :: ClipperLib :: PolyFillType , ) -> bool ;
        }
        extern "C" {
            # [ link_name = "\u{1}_ZN10ClipperLib7Clipper7ExecuteENS_8ClipTypeERNS_8PolyTreeENS_12PolyFillTypeES4_" ] 
 pub fn Clipper_Execute3 ( this : * mut root :: ClipperLib :: Clipper , clipType : root :: ClipperLib :: ClipType , polytree : * mut root :: ClipperLib :: PolyTree , subjFillType : root :: ClipperLib :: PolyFillType , clipFillType : root :: ClipperLib :: PolyFillType , ) -> bool ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib7ClipperC1Ei"]
            pub fn Clipper_Clipper(
                this: *mut root::ClipperLib::Clipper,
                initOptions: ::std::os::raw::c_int,
            );
        }
        impl Clipper {
            #[inline]
            pub unsafe fn Execute(
                &mut self,
                clipType: root::ClipperLib::ClipType,
                solution: *mut root::ClipperLib::Paths,
                fillType: root::ClipperLib::PolyFillType,
            ) -> bool {
                Clipper_Execute(self, clipType, solution, fillType)
            }
            #[inline]
            pub unsafe fn Execute1(
                &mut self,
                clipType: root::ClipperLib::ClipType,
                solution: *mut root::ClipperLib::Paths,
                subjFillType: root::ClipperLib::PolyFillType,
                clipFillType: root::ClipperLib::PolyFillType,
            ) -> bool {
                Clipper_Execute1(self, clipType, solution, subjFillType, clipFillType)
            }
            #[inline]
            pub unsafe fn Execute2(
                &mut self,
                clipType: root::ClipperLib::ClipType,
                polytree: *mut root::ClipperLib::PolyTree,
                fillType: root::ClipperLib::PolyFillType,
            ) -> bool {
                Clipper_Execute2(self, clipType, polytree, fillType)
            }
            #[inline]
            pub unsafe fn Execute3(
                &mut self,
                clipType: root::ClipperLib::ClipType,
                polytree: *mut root::ClipperLib::PolyTree,
                subjFillType: root::ClipperLib::PolyFillType,
                clipFillType: root::ClipperLib::PolyFillType,
            ) -> bool {
                Clipper_Execute3(self, clipType, polytree, subjFillType, clipFillType)
            }
            #[inline]
            pub unsafe fn new(initOptions: ::std::os::raw::c_int) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Clipper_Clipper(&mut __bindgen_tmp, initOptions);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10ClipperLib7Clipper15ExecuteInternalEv"]
            pub fn Clipper_ExecuteInternal(this: *mut ::std::os::raw::c_void) -> bool;
        }
    }
    #[test]
    fn __bindgen_test_layout__List_node_open0_size_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::_List_node<usize>>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::_List_node<usize>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::_List_node<usize>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::_List_node<usize>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_IntPoint_allocator_open1_IntPoint_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_IntPoint_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_Path_allocator_open1_vector_open2_IntPoint_allocator_open3_IntPoint_close3_close2_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_vector_open1_IntPoint_allocator_open2_IntPoint_close2_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_IntPoint_allocator_open1_IntPoint_close1_close0_instantiation_1(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_IntPoint_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_PolyNode_allocator_open1_ptr_PolyNode_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_PolyNode_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_OutRec_allocator_open1_ptr_OutRec_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_OutRec_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_TEdge_allocator_open1_ptr_TEdge_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_TEdge_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_Join_allocator_open1_ptr_Join_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_Join_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_ptr_IntersectNode_allocator_open1_ptr_IntersectNode_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_ptr_IntersectNode_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    pub type size_type = usize;
    #[test]
    fn __bindgen_test_layout_vector_open0_LocalMinimum_allocator_open1_LocalMinimum_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_LocalMinimum_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout___normal_iterator_open0_pointer_vector_open1_LocalMinimum_allocator_open2_LocalMinimum_close2_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::__gnu_cxx::__normal_iterator<root::pointer>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::__gnu_cxx::__normal_iterator<root::pointer>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::__gnu_cxx::__normal_iterator<root::pointer>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::__gnu_cxx::__normal_iterator<root::pointer>)
            )
        );
    }
    pub type pointer = *mut root::ClipperLib::LocalMinimum;
    #[test]
    fn __bindgen_test_layout_vector_open0_LocalMinimum_allocator_open1_LocalMinimum_close1_close0_instantiation_1(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_LocalMinimum_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_priority_queue_open0_cInt_vector_open1_long_long_allocator_open2_long_long_close2_close1_less_open1_long_long_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::priority_queue<root::std::vector, root::std::less>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify ! ( root :: std :: priority_queue < root :: std :: vector , root :: std :: less > )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::priority_queue<root::std::vector, root::std::less>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify ! ( root :: std :: priority_queue < root :: std :: vector , root :: std :: less > )
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_vector_open0_long_long_allocator_open1_long_long_close1_close0_instantiation(
) {
        assert_eq!(
            ::std::mem::size_of::<root::std::vector>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::vector)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::vector>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::vector)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_long_long_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_less_open0_long_long_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::less>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::less)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::less>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::less)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_list_open0_cInt_allocator_open1_long_long_close1_close0_instantiation()
    {
        assert_eq!(
            ::std::mem::size_of::<root::std::list>(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::list)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::list>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::list)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_long_long_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
}
